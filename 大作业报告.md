# 基于 egui_graphs 的交互式图可视化工具开发报告

**课程名称：** 可信开源软件技术
**学生姓名：** 李子昂
**学号：** 20232241100
**完稿日期：** 2025年5月31日

## 摘要

本文档详细阐述了基于Rust编程语言及其生态系统中的`egui`图形用户界面（GUI）框架与`egui_graphs`图可视化库，从一个基础示例出发，逐步设计、开发并完善一个名为`egui_basic_standalone`的独立、交互式图可视化应用程序的完整过程。报告深入探讨了项目的需求分析、技术选型、系统架构设计、核心功能模块的实现细节、开发过程中遇到的关键技术挑战及其解决方案，以及通过Git进行版本控制的实践经验。本项目成功实现了一系列核心功能，包括但不限于：动态图数据的创建与管理、支持中文字符的界面与节点标签显示、通过可配置的侧边栏UI动态调整图的样式与交互行为、有向图与无向图之间的平滑切换（保留节点位置与数据）、节点与边的权重属性支持及其动态编辑、以及集成`fdg`力导向布局库实现图的自动布局。最终的应用展示了Rust在构建功能丰富、响应迅速的桌面图形应用方面的潜力，并为后续的进一步功能扩展奠定了坚实基础。

**关键词：** Rust, egui, egui_graphs, 图可视化, GUI应用, 软件工程实践, 版本控制, 力导向布局

## 1. 引言

### 1.1 项目背景与意义
在当今信息爆炸的时代，数据可视化已成为从复杂数据集中提取有价值信息、洞察模式、辅助决策的关键技术。图（Graph）作为一种能够高效表示实体间复杂关系的数据结构，在社交网络分析、知识图谱构建、生物信息学、物流网络优化、金融风险控制等众多领域均有广泛应用。开发一款直观、交互性强的图可视化工具，不仅能够帮助用户更好地理解和分析图数据，也对相关领域的科研与实践具有重要推动作用。

Rust语言凭借其内存安全、高性能和并发优势，在系统编程领域取得了显著成就，并逐渐在桌面应用、游戏开发及WebAssembly等领域展现出巨大潜力。`egui`作为一个纯Rust实现的即时模式GUI库，以其简洁易用、跨平台和高性能的特点，为Rust开发者提供了构建图形界面的新选择。`egui_graphs`库则是在`egui`基础上针对图可视化场景的扩展。本项目旨在结合这些先进技术，探索使用Rust构建实用型图可视化工具的可行性与优势，并通过一个完整的开发实践，深化对相关技术的理解和应用能力。

### 1.2 项目目标与范围
本项目的主要目标是基于`egui_graphs`库，从其提供的基础示例代码入手，通过一系列功能迭代和代码重构，开发一个功能相对完善、可独立运行的桌面图可视化应用程序——`egui_basic_standalone`。具体目标包括：
1.  **独立应用构建**：将示例代码转化为一个独立的、可配置依赖、可编译运行的Rust项目。
2.  **核心功能实现**：
    *   支持图数据的动态加载与展示，节点和边能承载自定义信息（如标签、权重）。
    *   提供友好的用户界面，支持中文字符显示。
    *   实现一个可交互的配置面板，允许用户动态调整图的视觉样式、导航方式和交互行为。
    *   支持有向图与无向图之间的动态切换，并在切换时保持图数据和节点布局的稳定性。
    *   实现节点和边的权重属性，并提供UI界面进行查看和编辑。
    *   集成力导向布局算法，实现图的自动美观布局。
    *   支持对图结构的基本动态编辑，如添加和删除节点与边。
3.  **技术实践与深化**：在项目中熟练运用Rust语言特性、`egui`框架和`egui_graphs`库，掌握Git版本控制的最佳实践，并有效解决开发过程中遇到的技术难题。

项目范围限定在桌面端应用的开发，重点关注图的可视化、基本交互配置以及核心数据模型的构建。

### 1.3 技术选型
为实现上述目标，项目采用了以下技术栈：
*   **编程语言**: Rust (Edition 2021)，利用其安全性、性能及强大的生态系统。
*   **GUI框架**: `egui` (v0.31.0) 与 `eframe` (v0.31.0)，因其纯Rust实现、即时模式的简洁性和跨平台能力。
*   **图可视化库**: `egui_graphs` (v0.24.0)，作为`egui`的扩展，提供图的渲染和基本交互。
*   **力导向布局库**: `fdg` (特定Git commit `44f6c1bc`)，用于实现图的自动美观布局。
*   **底层图数据结构**: `petgraph` (v0.7)，`egui_graphs`依赖此库进行图的存储和操作。
*   **版本控制**: Git，用于项目代码的版本管理和协作。

## 2. 系统设计与实现

### 2.1 整体架构与模块化设计
随着功能的不断迭代，项目从最初的单一`main.rs`文件演化为一个结构更清晰的模块化设计，以提升代码的可维护性和可读性。应用程序的核心逻辑和状态管理被封装在`BasicApp`结构体中，该结构体实现了`eframe::App` trait。

重构后的`src/`目录结构如下：
*   **`main.rs`**: 作为程序的唯一入口点。其`main()`函数负责初始化`eframe`的本地运行环境（`NativeOptions`）并启动`BasicApp`实例。同时，它声明了项目所需的其他核心模块。
*   **`app.rs`**: 定义了应用的核心逻辑。`BasicApp`结构体在此文件中定义，集中管理了应用的所有状态数据，包括当前的图对象（`AppGraph`，一个封装了有向或无向图的枚举）、力导向模拟器实例（`fdg::ForceGraph`）、UI配置参数（如标签显示、导航模式、交互开关等）、以及用于UI输入的临时状态变量（如节点标签、权重输入）。`impl BasicApp`块包含了应用的大部分方法，如构造函数`new()`，图的初始化与重置逻辑 (`reset_graph_and_simulation()`)，图数据填充 (`populate_graph_data()`)，图方向转换 (`convert_graph_direction()`)，节点和边的动态增删改查，以及与力导向模拟器的交互（如`update_simulation()`, `sync_node_positions_to_egui()`, `sync_egui_positions_to_fdg()`）和图事件处理 (`handle_events()`)。`impl eframe::App for BasicApp`中的`update()`方法则作为每帧的驱动函数，协调UI绘制和逻辑更新。此外，核心数据结构如`NodePayload { label, weight }`和`EdgePayload { label, weight }`也在此定义。
*   **`settings_panel.rs`**: 专注于应用程序右侧配置面板的UI渲染。它包含一个主函数`draw_settings_panel(&mut BasicApp, &Context)`，该函数接收`BasicApp`的可变引用以读取和修改应用状态，并使用`egui`的各种控件（如复选框、滑块、按钮、文本输入框）构建交互界面。为了代码的清晰性，面板内的UI元素被进一步组织到多个私有的辅助绘图函数中，分别处理图属性、样式、导航、交互、模拟、节点/边管理、选中元素属性编辑以及调试信息等不同配置区域。
*   **`graph_view.rs`**: 负责在应用程序的中央区域渲染交互式图表。其核心函数`draw_graph_view(&mut BasicApp, &Context, &mut Frame)`根据`BasicApp`中存储的图数据 (`app.g`) 和相关的显示配置（如样式、导航、交互设置），实例化并配置`egui_graphs::GraphView`小部件，然后将其添加到UI中进行绘制。

这种模块化的设计将应用的状态管理、核心逻辑、UI面板渲染和图表渲染等不同关注点清晰地分离到各自的文件中，显著提高了代码的可读性、可维护性和可扩展性。

### 2.2 核心数据结构
项目的核心数据围绕`BasicApp`结构体展开，其中关键的自定义数据结构包括：
*   **`NodePayload`**: `struct NodePayload { pub label: String, pub weight: f32 }`，用于存储每个节点的自定义数据，包括一个用户可见的字符串标签和一个浮点数权重。
*   **`EdgePayload`**: `struct EdgePayload { pub label: String, pub weight: f32 }`，类似地存储每条边的标签和权重。
*   **`AppGraph`**: `enum AppGraph { Directed(Graph<NodePayload, EdgePayload, Directed>), Undirected(Graph<NodePayload, EdgePayload, Undirected>) }`。这个枚举是管理图方向性的关键，它允许`BasicApp`在运行时持有一个具体类型的`egui_graphs::Graph`实例（或者是有向图，或者是无向图），同时对外提供统一的访问接口。

`BasicApp`还维护一个`node_label_to_index_map: HashMap<String, NodeIndex<DefaultIx>>`，用于在需要通过节点标签（例如从`fdg`模拟器获取的负载信息）查找其在`petgraph`图中的内部索引时提供快速映射。

### 2.3 主要功能模块实现
**1. 图的创建、显示与基本交互：**
图的底层存储和操作主要依赖`petgraph::StableGraph`。`egui_graphs::Graph`则是在`petgraph`图基础上构建的、用于`egui`显示的封装。`BasicApp::new()`和`BasicApp::reset_graph_and_simulation()`负责根据配置（如节点数、边数、是否有向）创建`StableGraph`实例，填充随机数据（通过`populate_graph_data`），然后从中生成`egui_graphs::Graph`实例。`graph_view.rs`中的`draw_graph_view`函数则负责每一帧使用`egui_graphs::GraphView`将此图渲染出来。`GraphView`本身处理了节点的拖拽、点击、选择等基本交互，并通过事件通道 (`event_publisher`) 将这些交互事件发送出来。

**2. UI配置面板：**
如前所述，`settings_panel.rs`构建了一个丰富的配置界面。用户可以通过复选框、滑块和按钮实时调整图的各种属性。例如：
*   **图属性**：切换有向/无向（触发`convert_graph_direction`），调整节点/边数量（触发`reset_graph_and_simulation`）。
*   **样式**：控制标签是否总是显示。
*   **导航**：启用/禁用适应屏幕、缩放和平移，调整缩放速度。
*   **交互**：细致控制节点和边的拖拽、点击、单选和多选行为。
*   **模拟**：启动/停止力导向模拟，调整模拟参数（时间步长、冷却因子、缩放尺度）。
*   **节点/边管理**：通过输入框添加带标签和权重的节点/边；通过按钮操作在选中节点间添加边或删除选中的边。
*   **选中元素属性**：当单个节点或边被选中时，显示其标签和权重，并允许修改权重。

**3. 力导向布局：**
项目集成了`fdg`库来实现Fruchterman-Reingold力导向布局算法。`BasicApp`中持有`fdg::ForceGraph`实例（`self.sim`）和算法配置（`self.force_algo`）。
*   **初始化**: 在图创建或重置时，会根据当前的`petgraph`图结构（始终转换为有向图表示）调用`fdg::init_force_graph_uniform`来初始化`self.sim`。
*   **模拟更新**: 在`BasicApp::update_simulation()`中，如果模拟未停止，则调用`Force::apply(&mut self.force_algo, &mut self.sim)`执行一步模拟计算。
*   **位置同步 (fdg -> egui_graphs)**: `BasicApp::sync_node_positions_to_egui()`负责将`self.sim`中计算出的节点位置同步到`self.g`（`egui_graphs::Graph`实例）中，以便UI更新。此过程依赖`node_label_to_index_map`通过节点标签进行匹配。
*   **位置同步 (egui_graphs -> fdg)**: 当用户拖拽节点（通过`handle_events`更新`self.sim`中的位置）或在图方向转换后保持节点位置不变时（通过`sync_egui_positions_to_fdg`），需要将`egui_graphs`中的权威位置写回到`self.sim`中，以确保模拟状态与显示一致。

**4. 图方向切换：**
`BasicApp::convert_graph_direction()`方法是此功能的核心。当用户切换`is_directed`状态时：
1.  它首先遍历当前`self.g`中的所有节点和边，保存它们的`NodePayload`、`EdgePayload`以及每个节点当前的屏幕位置 (`egui::Pos2`)。
2.  然后，根据新的`is_directed`状态，创建一个新的、正确类型的`petgraph::StableGraph`（`Directed`或`Undirected`）。
3.  将保存的节点和边数据添加到这个新的`petgraph::StableGraph`中。在此过程中，会重新构建`node_label_to_index_map`，并记录旧索引到新索引的映射，以确保后续位置应用的正确性。
4.  从新的`petgraph::StableGraph`创建对应类型的`egui_graphs::Graph`实例，并立即将之前保存的节点屏幕位置应用到这个新图的节点上。
5.  更新`self.g`指向这个新的`egui_graphs::Graph`。
6.  为`fdg`模拟器准备一个新的有向`petgraph::StableGraph`（如果新图是无向的，则从无向图转换得到），并用它重新初始化`self.sim`。
7.  最后，调用`self.sync_egui_positions_to_fdg()`将`egui_graphs`中保持不变的节点位置同步到新初始化的`self.sim`中，并清除模拟速度，从而确保切换时节点在屏幕上“不动”。

**5. 节点与边的动态编辑与权重管理：**
*   **添加节点/边**: `BasicApp::add_node_ui`和`BasicApp::add_edge_ui`方法接收来自UI的标签和权重输入，创建相应的`NodePayload`或`EdgePayload`，然后同时更新`self.g`（`egui_graphs::Graph`）和`self.sim`（`fdg::ForceGraph`）中的图结构。
*   **删除节点/边**: `BasicApp::remove_node_ui`和`BasicApp::remove_selected_edges_ui`类似地操作，确保两个图实例的数据一致性。
*   **权重编辑**: `settings_panel.rs`中的`draw_selected_element_properties`函数，当检测到单个节点或边被选中时，会调用`app.get_node_payload_mut()`或`app.get_edge_payload_mut()`获取对应payload的可变引用。`egui::DragValue`可以直接修改这个引用中的`weight`字段。当修改发生时，会进一步调用`app.update_fdg_node_payload()`或`app.update_fdg_edge_payload()`来确保`fdg`模拟器内部存储的payload副本也得到更新。

**6. 中文字体支持：**
在`BasicApp::new()`中，通过`egui::FontDefinitions`加载本地中文字体文件（如Windows下的宋体`simsun.ttc`）。将加载的字体数据插入到`fonts.font_data`中，并将其设置为`FontFamily::Proportional`和`FontFamily::Monospace`的优先字体。这确保了`egui`渲染的所有文本（包括UI控件和`egui_graphs`的节点/边标签）都能正确显示中文字符。

## 3. 开发过程与关键技术点回顾

项目的开发并非一帆风顺，而是经历了一个不断尝试、解决问题、迭代优化的过程。
初期，主要工作是将`egui_graphs`的官方示例独立出来，并使其能够稳定编译运行。随后，逐步添加了自定义节点数据（`String`标签）、节点标签永久显示等基本功能。中文字体的支持是一个重要的里程碑，涉及到字体文件的加载、`egui`字体系统的配置，确保了应用的本地化体验。

一个主要的挑战来自于**依赖管理和版本兼容性**。在尝试集成`fdg`力导向布局库时，由于其依赖的`egui`版本（较新）与项目中`egui_graphs`所依赖的`egui`版本（较旧）不一致，导致了大量的编译错误（如`Pos2`类型冲突、`Widget` trait不兼容）。解决方案是将整个项目的`egui`和`eframe`依赖升级到一个较新的版本（v0.31.0），并对代码中因API变更导致的不兼容之处进行适配。这个过程强调了在Rust生态中处理传递依赖和版本更新的重要性。

**图方向切换功能**的实现是一个复杂点。最初的实现是在切换时完全重置图，这会导致用户数据的丢失和视觉上的跳变。根据用户反馈，优化为在切换时保留节点数据和屏幕位置，这需要仔细处理图数据的提取、新图的构建、索引映射以及与`fdg`模拟器的状态同步，确保切换过程的平滑和数据的完整性。

**权重功能的引入**涉及到对核心数据结构`NodePayload`和`EdgePayload`的扩展，并需要更新所有涉及图数据创建、修改和显示的地方。UI层面则需要添加相应的输入和编辑控件，并确保修改能够正确反映到底层数据和模拟器状态中。

在整个开发过程中，**Git版本控制**发挥了至关重要的作用。通过为每个主要功能点或修复创建原子性的提交，并编写清晰的提交信息，使得开发历史易于追溯和理解。当遇到难以解决的问题或需要回退到之前的稳定状态时，Git提供了强大的支持。

**调试和问题定位**也是开发过程中的常态。Rust编译器的严格检查虽然有时显得繁琐，但它确实帮助在编译阶段就发现和修正了许多潜在的运行时错误。对于逻辑错误或与第三方库API理解不一致导致的问题，则需要通过打印调试信息、阅读库文档和源码、以及逐步简化问题场景等方式进行定位和解决。例如，确定`fdg`特定版本`node_weights()`的返回类型，以及`egui_graphs`中`GraphView`的泛型参数推断问题，都花费了一定的时间和精力。

## 4. 结果与讨论

经过一系列的开发与迭代，`egui_basic_standalone`项目成功实现了一个功能相对完善的交互式图可视化应用。用户可以通过图形界面方便地创建、配置和观察图的结构与布局。
**主要成果包括：**
*   **模块化的代码结构**：提高了项目的可维护性和扩展性。
*   **丰富的UI配置**：用户可以自由调整图的多种显示和交互参数。
*   **动态图编辑**：支持运行时添加/删除节点和边，以及修改其权重。
*   **平滑的图类型转换**：在有向图和无向图之间切换时，用户数据和节点布局得以保留。
*   **自动布局**：集成了力导向算法，能够对图进行自动布局。
*   **良好的本地化支持**：正确显示中文字符。

**讨论与局限性：**
*   **性能**：对于非常大规模的图（数千节点或边），当前的实现（特别是`fdg`的JavaScript桥接或纯Rust版本的性能）可能会遇到性能瓶颈。进一步的性能分析和优化（如更高效的渲染策略、WebAssembly优化、或使用更高性能的布局算法）是未来可以探索的方向。
*   **权重可视化**：虽然数据结构和UI支持了权重，但权重信息目前并未直接反映在图的视觉表现上（例如节点大小、边的粗细或颜色）。这是一个重要的可视化增强点。
*   **布局算法**：目前仅集成了Fruchterman-Reingold算法。引入更多种类的布局算法（如层次布局、圆形布局等）能满足更多样化的可视化需求。
*   **错误处理与用户反馈**：当前的错误处理主要依赖于控制台打印，对于用户操作的错误（如输入无效）缺乏友好的UI反馈。
*   **功能完整性**：与商业图可视化软件相比，本项目在功能上仍有较大差距，例如不支持图数据的导入导出、复杂的图分析算法集成、高级自定义渲染等。

尽管存在上述局限性，本项目作为一次学习和实践，成功地展示了使用Rust及其生态库构建此类应用的可行性和潜力。

## 5. 总结与展望

本项目从一个简单的`egui_graphs`示例开始，通过逐步的功能添加、代码重构和问题解决，最终实现了一个具备核心交互能力的独立图可视化应用`egui_basic_standalone`。在整个开发过程中，我们深入实践了Rust语言编程、`egui`即时模式GUI开发、`egui_graphs`图可视化库的使用、`fdg`力导向布局的集成，以及Git版本控制等现代软件工程方法。通过解决依赖管理、API适配、类型系统和借用检查等具体技术挑战，显著提升了对Rust生态和软件开发全周期的理解与实践能力。

**主要学习收获包括：**
*   对Rust所有权、生命周期、泛型和Trait等核心概念在实际项目中的应用有了更深刻的体会。
*   掌握了`egui`框架的基本使用方法和即时模式GUI的设计思想。
*   熟悉了`egui_graphs`和`petgraph`库在图数据表示和可视化方面的应用。
*   积累了处理第三方库版本兼容性和API变化的经验。
*   体验了从需求分析、设计、编码、调试到文档撰写的完整软件开发流程。

**未来展望：**
`egui_basic_standalone`项目仍有广阔的提升空间和扩展方向：
1.  **性能优化**：针对大规模图的渲染和布局进行性能分析与优化。
2.  **可视化增强**：实现基于节点/边权重或其他属性的视觉编码（如大小、颜色、形状）。
3.  **高级交互**：支持更复杂的图编辑操作（如节点合并、子图折叠）、路径查找高亮等。
4.  **图算法集成**：集成`petgraph`或其他库提供的图分析算法（如最短路径、中心性计算、社区发现），并将结果可视化。
5.  **数据持久化**：实现图数据的导入（如GraphML, GEXF, CSV格式）和导出功能，以及应用配置的保存与加载。
6.  **用户体验提升**：完善错误提示和用户引导，提供更美观和可定制的主题。
7.  **WebAssembly部署**：利用`egui`的跨平台特性，尝试将应用编译为WebAssembly在浏览器中运行。

通过持续的迭代和完善，`egui_basic_standalone`有望发展成为一款更为强大和实用的图可视化与分析工具。本次项目实践为后续在Rust和数据可视化领域的深入探索打下了坚实的基础。

## 参考文献
*   egui documentation: [https://docs.rs/egui/](https://docs.rs/egui/)
*   eframe documentation: [https://docs.rs/eframe/](https://docs.rs/eframe/)
*   egui_graphs documentation: [https://docs.rs/egui_graphs/](https://docs.rs/egui_graphs/)
*   petgraph documentation: [https://docs.rs/petgraph/](https://docs.rs/petgraph/)
*   fdg repository: [https://github.com/grantshandy/fdg](https://github.com/grantshandy/fdg)
*   The Rust Programming Language Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)